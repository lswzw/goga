# GoGa - 开发任务拆解 (v1.0)

本文档根据系统设计将项目开发分解为一系列可执行的任务。任务按阶段划分，并根据依赖关系进行了优先级排序，确保项目可以迭代、平稳地推进。开发应遵循从底层基础到上层功能的顺序。

---

### Phase 1: 核心反向代理基础

**目标**: 搭建一个可以运行的、功能最小化的 HTTP 反向代理服务器。此阶段不涉及任何加解密逻辑。

- [x] **1.1. 项目初始化与结构搭建**
  - **描述**: 初始化 Go Module (`go mod init`)，并创建设计文档中规划的目录结构 (`cmd/goga`, `configs`, `internal/gateway`, `docs`)。
  - **优先级**: 最高 (项目基石)。
  - **产出**: 一个空的、结构清晰的项目骨架。

- [x] **1.2. 配置模块实现**
  - **描述**: 在 `configs` 包中实现配置加载逻辑。使用 Viper 读取 `config.yaml` 和环境变量 (`server.port`, `backend_url`, `log_level`)。
  - **优先级**: 高。
  - **依赖**: 1.1
  - **产出**: 一个可以加载项目配置的 `config` 模块。

- [x] **1.3. 基础 HTTP 服务启动**
  - **描述**: 在 `cmd/goga/main.go` 中编写主函数。该函数负责加载配置，并启动一个监听在指定端口的 `http.Server`。
  - **优先级**: 高。
  - **依赖**: 1.2
  - **产出**: 一个可以启动并监听端口的空 Web 服务器。

- [x] **1.4. 实现基础反向代理处理器**
  - **描述**: 在 `internal/gateway` 中创建一个 `NewProxy` 函数，该函数使用 `net/http/httputil.ReverseProxy` 创建一个将所有请求转发到 `backend_url` 的 `http.Handler`。
  - **优先级**: 高。
  - **依赖**: 1.3
  - **产出**: 一个能将所有流量正确转发到后端的、可工作的反向代理。

- [x] **1.5. 实现基础中间件 (日志、恢复、健康检查)**
  - **描述**: 创建一个 `middleware` 包，并实现三个基础中间件：
    1.  请求日志 (Logging): 记录方法、路径、状态码、耗时。
    2.  Panic 恢复 (Recovery): 捕获 panic 并返回 500 错误。
    3.  健康检查 (Health Check): 为 `/healthz` 路径返回 `200 OK`。
  - **优先级**: 中。这些是后续调试的重要辅助工具。
  - **依赖**: 1.4
  - **产出**: 一个包裹了代理处理器，并具备基本运维功能的服务。

---

### Phase 2: HTML 响应处理与脚本注入

**目标**: 在核心代理的基础上，实现对 HTML 响应的识别和动态脚本注入功能。

- [x] **2.1. 实现脚本注入逻辑**
  - **描述**: 修改 `internal/gateway` 中的代理处理器，为其 `ModifyResponse` 钩子添加逻辑。该逻辑需要检测响应的 `Content-Type`，如果是 `text/html`，则读取并修改响应体，在 `</body>` 前插入脚本标签。
  - **优先级**: 高。
  - **依赖**: Phase 1 完成。
  - **产出**: 访问 HTML 页面时，响应体中会被自动注入 `<script>` 标签。

- [x] **2.2. 创建并服务化加密脚本文件**
  - **描述**:
    1.  在项目下创建一个 `static` 或类似目录，并放入一个空的 `goga-crypto.js` 文件。
    2.  在网关的路由逻辑中添加一个处理器，用于响应 `GET /goga-crypto.js` 请求，并返回该文件的内容。
  - **优先级**: 高。
  - **依赖**: 2.1
  - **产出**: 浏览器可以通过网关正确下载 `goga-crypto.js` 文件，避免 404 错误。

---

### Phase 3: 服务端加解密核心功能

**目标**: 构建服务端的密钥管理、分发和请求解密能力。

- [x] **3.1. 实现服务端加密工具模块**
  - **描述**: 在 `internal` 中创建一个 `crypto` 包，实现 `AES-256-GCM` 的解密函数。该函数应接受密钥和密文（nonce + ciphertext）作为输入，返回明文。编写对应的单元测试。
  - **优先级**: 最高 (本阶段的基础)。
  - **依赖**: 无外部依赖。
  - **产出**: 一个经过充分测试的、可靠的 `crypto` 工具包。

- [x] **3.2. 实现内存密钥缓存**
  - **描述**: 在 `internal/gateway` 中创建一个 `keycache` 模块。该模块需要实现一个线程安全的、带 TTL (Time-To-Live) 的内存缓存，用于存储 `token` 到 `ONETIME_KEY` 的映射。
  - **优先级**: 高。
  - **依赖**: 无外部依赖。
  - **产出**: 一个用于临时存储一次性密钥的缓存服务。

- [x] **3.3. 实现密钥分发 API 端点**
  - **描述**: 在网关的路由中添加 `GET /goga/api/v1/key` 的处理器。该处理器负责：
    1.  生成一个唯一 `token` 和一个随机的 `ONETIME_KEY`。
    2.  将 `(token, ONETIME_KEY)` 存入密钥缓存。
    3.  以 JSON 格式向客户端返回 `{"key": "...", "token": "..."}`。
  - **优先级**: 中。
  - **依赖**: 3.2
  - **产出**: 客户端可以通过此 API 获取加密所需的一次性密钥和令牌。

- [x] **3.4. 实现请求解密中间件**
  - **描述**: 创建 `DecryptionMiddleware`。该中间件负责：
    1.  检查 `POST` 请求和 `Content-Type`。
    2.  解析 `{"token": ..., "encrypted": ...}` 格式的请求体。
    3.  使用 `token` 从密钥缓存中获取密钥。
    4.  调用 `crypto` 模块解密数据。
    5.  用解密后的明文替换原始请求体，并更新 `Content-Type` 和 `Content-Length`。
  - **优先级**: 中。
  - **依赖**: 3.1, 3.2, 3.3
  - **产出**: 网关能够自动解密符合特定格式的传入请求。

---

### Phase 4: 客户端加密实现

**目标**: 完成客户端 `goga-crypto.js` 的逻辑，使其能够与服务端协同完成整个加密流程。

- [x] **4.1. 编写客户端加密脚本**
  - **描述**: 填充 `goga-crypto.js` 文件的内容，实现设计文档中描述的全部逻辑：
    1.  监听并阻止表单默认提交。
    2.  异步从 `/goga/api/v1/key` 获取密钥和令牌。
    3.  序列化表单数据为 JSON。
    4.  使用 `SubtleCrypto` API (或 `crypto-js`) 执行 `AES-256-GCM` 加密。
    5.  构造加密载荷，并通过 `fetch` 发送到表单的 `action` URL。
  - **优先级**: 高。
  - **依赖**: Phase 3 完成。
  - **产出**: 一个功能完整的客户端加密脚本。

---

### Phase 5: 集成与文档

**目标**: 将所有功能集成在一起，进行端到端测试，并完善文档和配置。

- [x] **5.1. 端到端集成测试**

  - **描述**: 创建一个简单的后端测试服务（例如，一个打印出收到的请求体和头部的 Node.js Express 或 Go HTTP 服务器）。然后手动或通过自动化测试工具，验证整个流程：页面加载 -> 脚  - **本注入 -> 表单提交 -> 加密 -> 解密 -> 后端收到明文。
  - **优先级**: 高。
  - **依赖**: Phase 1-4 全部完成。
  - **产出**: 证明整个系统按预期工作的测试结果。

- [x] **5.2. 添加 TLS 支持**
  - **描述**: 在 `main.go` 中添加入口逻辑，当配置文件中提供了 `tls_cert_path` 和 `tls_key_path` 时，使用 `http.ListenAndServeTLS` 启动服务。
  - **优先级**: 中。
  - **依赖**: Phase 1 完成。
  - **产出**: 网关支持 HTTPS。

- [x] **5.3. 完善文档**
  - **描述**: 更新 `README.md`，提供清晰的编译、配置和运行指南。说明所有配置项的含义和用法。
  - **优先级**: 中。
  - **依赖**: Phase 1-4 全部完成。
  - **产出**: 一份对用户友好的项目说明文档。

---

### Phase 6: 前端性能优化与健壮性提升

**目标**: 优化客户端加密脚本的性能，减少不必要的网络请求，并增强在密钥过期时的用户体验。

- [x] **6.1. 在 goga-crypto.js 中引入客户端密钥缓存**
  - **描述**: 在 `goga-crypto.js` 脚本的闭包（IIFE）中，定义一个用于存储加密密钥、令牌和过期时间戳的内存变量。此缓存将随页面刷新而自动清除。
  - **优先级**: 高。
  - **依赖**: Phase 4 完成。
  - **产出**: 脚本内部具备了存储密钥的缓存结构。

- [x] **6.2. 实现缓存感知的加密流程**
  - **描述**: 修改 `fetch` 拦截器中的加密逻辑。在加密数据前，首先检查密钥缓存。如果缓存中存在有效且未过期的密钥，则直接使用该密钥，跳过网络请求。
  - **优先级**: 高。
  - **依赖**: 6.1
  - **产出**: 在缓存有效期内，重复的 API 调用不再触发对 `/goga/api/v1/key` 的请求。

- [x] **6.3. 实现密钥过期后的无缝自动续期**
  - **描述**: 增强缓存检查逻辑。当检查到缓存中的密钥已过期或不存在时，脚本应能 **自动、透明地** 调用 `originalFetch` 获取新的密钥和令牌，更新缓存， **然后继续完成当前被拦截的加密请求**。此过程对用户无感知，不会因密钥过期而直接导致请求失败或报错。
  - **优先级**: 高 (核心用户体验)。
  - **依赖**: 6.2
  - **产出**: 即使用户长时间停留页面导致密钥过期，下一次 API 调用也能自动续期并成功完成，仅在该次调用时有获取密钥的额外延迟。

- [x] **6.4. 协调客户端与服务端的缓存超时策略**
  - **描述**: 在 `goga-crypto.js` 中为客户端缓存设置一个明确的超时时间（例如4分钟）。此时间必须小于 Go 后端 `keycache` 模块中为密钥设置的服务器端 TTL（例如5分钟），以避免客户端使用一个已被服务端丢弃的密钥。
  - **优先级**: 中。
  - **依赖**: 6.1, 3.2
  - **产出**: 一套协调一致的、能避免竞态问题的缓存超时策略。

---

### Phase 7: 日志系统升级与优化

**目标**: 引入标准的分级日志系统 (`log/slog`)，替换原有的标准库 `log` 调用，使 `log_level` 配置生效，并优化日志输出格式。

- [x] **7.1. 初始化分级日志系统**
  - **描述**: 在 `cmd/goga/main.go` 中，根据配置文件中的 `log_level` (例如 "debug", "info", "warn", "error") 来初始化 `slog` 日志记录器，并将其设置为全局默认实例。
  - **优先级**: 高 (后续任务的基础)。
  - **依赖**: 1.2 (配置模块)。
  - **产出**: 一个配置好的、可供全局使用的分级日志记录器。

- [x] **7.2. 迁移解密中间件日志**
  - **描述**: 修改 `internal/middleware/decryption.go`，将其中的 `log.Println` 调用替换为 `slog.Debug("请求解密成功，已转发至后端服务。")`。
  - **优先级**: 高。
  - **依赖**: 7.1
  - **产出**: 解密成功的日志仅在 `log_level` 设置为 `debug` 时才会显示。

- [x] **7.3. 迁移请求日志中间件**
  - **描述**: 修改 `internal/middleware/logging.go`，将其中的 `log.Printf` 调用替换为结构化的 `slog.Info` 调用，例如 `slog.Info("incoming request", "method", r.Method, "uri", r.RequestURI, "status", rw.statusCode)`。
  - **优先级**: 高。
  - **依赖**: 7.1
  - **产出**: 请求日志以更清晰、结构化的键值对格式输出。

---

### Phase 8: 打包与部署

**目标**: 为项目添加容器化支持和自动化构建流程，简化部署和发布过程。

- [x] **8.1. 创建 Dockerfile**
  - **描述**: 编写一个多阶段的 `Dockerfile`。第一阶段使用 `golang` 镜像编译 Go 应用，生成一个静态链接的二进制文件。第二阶段使用一个轻量级的 `scratch` 或 `alpine` 镜像，仅复制编译好的二进制文件、`configs` 目录和 `static` 目录，以构建一个最小化的、安全的生产镜像。
  - **优先级**: 高。
  - **依赖**: Phase 1 完成。
  - **产出**: 一个可以工作的 `Dockerfile`，能够构建出可运行的 GoGa 镜像。

- [x] **8.2. 编写 Docker Compose 文件**
  - **描述**: 编写一个 `docker-compose.yml` 文件，仅用于启动 GoGa 网关服务。文件中所有注释必须为中文，且需将项目所有可配置项（如端口、日志级别、加密选项等）都通过环境变量暴露出来，并提供合理的默认值。
  - **优先级**: 中。
  - **依赖**: 8.1。
  - **产出**: 一个符合要求、注释清晰的 `docker-compose.yml` 文件。