# GoGa - 开发任务拆解 (v1.0)

本文档根据系统设计将项目开发分解为一系列可执行的任务。任务按阶段划分，并根据依赖关系进行了优先级排序，确保项目可以迭代、平稳地推进。开发应遵循从底层基础到上层功能的顺序。

---

### Phase 1: 核心反向代理基础

**目标**: 搭建一个可以运行的、功能最小化的 HTTP 反向代理服务器。此阶段不涉及任何加解密逻辑。

- [x] **1.1. 项目初始化与结构搭建**
  - **描述**: 初始化 Go Module (`go mod init`)，并创建设计文档中规划的目录结构 (`cmd/goga`, `configs`, `internal/gateway`, `docs`)。
  - **优先级**: 最高 (项目基石)。
  - **产出**: 一个空的、结构清晰的项目骨架。

- [x] **1.2. 配置模块实现**
  - **描述**: 在 `configs` 包中实现配置加载逻辑。使用 Viper 读取 `config.yaml` 和环境变量 (`server.port`, `backend_url`, `log_level`)。
  - **优先级**: 高。
  - **依赖**: 1.1
  - **产出**: 一个可以加载项目配置的 `config` 模块。

- [x] **1.3. 基础 HTTP 服务启动**
  - **描述**: 在 `cmd/goga/main.go` 中编写主函数。该函数负责加载配置，并启动一个监听在指定端口的 `http.Server`。
  - **优先级**: 高。
  - **依赖**: 1.2
  - **产出**: 一个可以启动并监听端口的空 Web 服务器。

- [x] **1.4. 实现基础反向代理处理器**
  - **描述**: 在 `internal/gateway` 中创建一个 `NewProxy` 函数，该函数使用 `net/http/httputil.ReverseProxy` 创建一个将所有请求转发到 `backend_url` 的 `http.Handler`。
  - **优先级**: 高。
  - **依赖**: 1.3
  - **产出**: 一个能将所有流量正确转发到后端的、可工作的反向代理。

- [x] **1.5. 实现基础中间件 (日志、恢复、健康检查)**
  - **描述**: 创建一个 `middleware` 包，并实现三个基础中间件：
    1.  请求日志 (Logging): 记录方法、路径、状态码、耗时。
    2.  Panic 恢复 (Recovery): 捕获 panic 并返回 500 错误。
    3.  健康检查 (Health Check): 为 `/healthz` 路径返回 `200 OK`。
  - **优先级**: 中。这些是后续调试的重要辅助工具。
  - **依赖**: 1.4
  - **产出**: 一个包裹了代理处理器，并具备基本运维功能的服务。

---

### Phase 2: HTML 响应处理与脚本注入

**目标**: 在核心代理的基础上，实现对 HTML 响应的识别和动态脚本注入功能。

- [x] **2.1. 实现脚本注入逻辑**
  - **描述**: 修改 `internal/gateway` 中的代理处理器，为其 `ModifyResponse` 钩子添加逻辑。该逻辑需要检测响应的 `Content-Type`，如果是 `text/html`，则读取并修改响应体，在 `</body>` 前插入脚本标签。
  - **优先级**: 高。
  - **依赖**: Phase 1 完成。
  - **产出**: 访问 HTML 页面时，响应体中会被自动注入 `<script>` 标签。

- [x] **2.2. 创建并服务化加密脚本文件**
  - **描述**:
    1.  在项目下创建一个 `static` 或类似目录，并放入一个空的 `goga-crypto.js` 文件。
    2.  在网关的路由逻辑中添加一个处理器，用于响应 `GET /goga-crypto.js` 请求，并返回该文件的内容。
  - **优先级**: 高。
  - **依赖**: 2.1
  - **产出**: 浏览器可以通过网关正确下载 `goga-crypto.js` 文件，避免 404 错误。

---

### Phase 3: 服务端加解密核心功能

**目标**: 构建服务端的密钥管理、分发和请求解密能力。

- [x] **3.1. 实现服务端加密工具模块**
  - **描述**: 在 `internal` 中创建一个 `crypto` 包，实现 `AES-256-GCM` 的解密函数。该函数应接受密钥和密文（nonce + ciphertext）作为输入，返回明文。编写对应的单元测试。
  - **优先级**: 最高 (本阶段的基础)。
  - **依赖**: 无外部依赖。
  - **产出**: 一个经过充分测试的、可靠的 `crypto` 工具包。

- [x] **3.2. 实现内存密钥缓存**
  - **描述**: 在 `internal/gateway` 中创建一个 `keycache` 模块。该模块需要实现一个线程安全的、带 TTL (Time-To-Live) 的内存缓存，用于存储 `token` 到 `ONETIME_KEY` 的映射。
  - **优先级**: 高。
  - **依赖**: 无外部依赖。
  - **产出**: 一个用于临时存储一次性密钥的缓存服务。

- [x] **3.3. 实现密钥分发 API 端点**
  - **描述**: 在网关的路由中添加 `GET /goga/api/v1/key` 的处理器。该处理器负责：
    1.  生成一个唯一 `token` 和一个随机的 `ONETIME_KEY`。
    2.  将 `(token, ONETIME_KEY)` 存入密钥缓存。
    3.  以 JSON 格式向客户端返回 `{"key": "...", "token": "..."}`。
  - **优先级**: 中。
  - **依赖**: 3.2
  - **产出**: 客户端可以通过此 API 获取加密所需的一次性密钥和令牌。

- [x] **3.4. 实现请求解密中间件**
  - **描述**: 创建 `DecryptionMiddleware`。该中间件负责：
    1.  检查 `POST` 请求和 `Content-Type`。
    2.  解析 `{"token": ..., "encrypted": ...}` 格式的请求体。
    3.  使用 `token` 从密钥缓存中获取密钥。
    4.  调用 `crypto` 模块解密数据。
    5.  用解密后的明文替换原始请求体，并更新 `Content-Type` 和 `Content-Length`。
  - **优先级**: 中。
  - **依赖**: 3.1, 3.2, 3.3
  - **产出**: 网关能够自动解密符合特定格式的传入请求。

---

### Phase 4: 客户端加密实现

**目标**: 完成客户端 `goga-crypto.js` 的逻辑，使其能够与服务端协同完成整个加密流程。

- [x] **4.1. 编写客户端加密脚本**
  - **描述**: 填充 `goga-crypto.js` 文件的内容，实现设计文档中描述的全部逻辑：
    1.  监听并阻止表单默认提交。
    2.  异步从 `/goga/api/v1/key` 获取密钥和令牌。
    3.  序列化表单数据为 JSON。
    4.  使用 `SubtleCrypto` API (或 `crypto-js`) 执行 `AES-256-GCM` 加密。
    5.  构造加密载荷，并通过 `fetch` 发送到表单的 `action` URL。
  - **优先级**: 高。
  - **依赖**: Phase 3 完成。
  - **产出**: 一个功能完整的客户端加密脚本。

---

### Phase 5: 集成与文档

**目标**: 将所有功能集成在一起，进行端到端测试，并完善文档和配置。

- [x] **5.1. 端到端集成测试**

  - **描述**: 创建一个简单的后端测试服务（例如，一个打印出收到的请求体和头部的 Node.js Express 或 Go HTTP 服务器）。然后手动或通过自动化测试工具，验证整个流程：页面加载 -> 脚  - **本注入 -> 表单提交 -> 加密 -> 解密 -> 后端收到明文。
  - **优先级**: 高。
  - **依赖**: Phase 1-4 全部完成。
  - **产出**: 证明整个系统按预期工作的测试结果。

- [x] **5.2. 添加 TLS 支持**
  - **描述**: 在 `main.go` 中添加入口逻辑，当配置文件中提供了 `tls_cert_path` 和 `tls_key_path` 时，使用 `http.ListenAndServeTLS` 启动服务。
  - **优先级**: 中。
  - **依赖**: Phase 1 完成。
  - **产出**: 网关支持 HTTPS。

- [x] **5.3. 完善文档**
  - **描述**: 更新 `README.md`，提供清晰的编译、配置和运行指南。说明所有配置项的含义和用法。
  - **优先级**: 中。
  - **依赖**: Phase 1-4 全部完成。
  - **产出**: 一份对用户友好的项目说明文档。

---

### Phase 6: 前端性能优化与健壮性提升

**目标**: 优化客户端加密脚本的性能，减少不必要的网络请求，并增强在密钥过期时的用户体验。

- [x] **6.1. 在 goga-crypto.js 中引入客户端密钥缓存**
  - **描述**: 在 `goga-crypto.js` 脚本的闭包（IIFE）中，定义一个用于存储加密密钥、令牌和过期时间戳的内存变量。此缓存将随页面刷新而自动清除。
  - **优先级**: 高。
  - **依赖**: Phase 4 完成。
  - **产出**: 脚本内部具备了存储密钥的缓存结构。

- [x] **6.2. 实现缓存感知的加密流程**
  - **描述**: 修改 `fetch` 拦截器中的加密逻辑。在加密数据前，首先检查密钥缓存。如果缓存中存在有效且未过期的密钥，则直接使用该密钥，跳过网络请求。
  - **优先级**: 高。
  - **依赖**: 6.1
  - **产出**: 在缓存有效期内，重复的 API 调用不再触发对 `/goga/api/v1/key` 的请求。

- [x] **6.3. 实现密钥过期后的无缝自动续期**
  - **描述**: 增强缓存检查逻辑。当检查到缓存中的密钥已过期或不存在时，脚本应能 **自动、透明地** 调用 `originalFetch` 获取新的密钥和令牌，更新缓存， **然后继续完成当前被拦截的加密请求**。此过程对用户无感知，不会因密钥过期而直接导致请求失败或报错。
  - **优先级**: 高 (核心用户体验)。
  - **依赖**: 6.2
  - **产出**: 即使用户长时间停留页面导致密钥过期，下一次 API 调用也能自动续期并成功完成，仅在该次调用时有获取密钥的额外延迟。

- [x] **6.4. 协调客户端与服务端的缓存超时策略**
  - **描述**: 在 `goga-crypto.js` 中为客户端缓存设置一个明确的超时时间（例如4分钟）。此时间必须小于 Go 后端 `keycache` 模块中为密钥设置的服务器端 TTL（例如5分钟），以避免客户端使用一个已被服务端丢弃的密钥。
  - **优先级**: 中。
  - **依赖**: 6.1, 3.2
  - **产出**: 一套协调一致的、能避免竞态问题的缓存超时策略。

---

### Phase 7: 日志系统升级与优化

**目标**: 引入标准的分级日志系统 (`log/slog`)，替换原有的标准库 `log` 调用，使 `log_level` 配置生效，并优化日志输出格式。

- [x] **7.1. 初始化分级日志系统**
  - **描述**: 在 `cmd/goga/main.go` 中，根据配置文件中的 `log_level` (例如 "debug", "info", "warn", "error") 来初始化 `slog` 日志记录器，并将其设置为全局默认实例。
  - **优先级**: 高 (后续任务的基础)。
  - **依赖**: 1.2 (配置模块)。
  - **产出**: 一个配置好的、可供全局使用的分级日志记录器。

- [x] **7.2. 迁移解密中间件日志**
  - **描述**: 修改 `internal/middleware/decryption.go`，将其中的 `log.Println` 调用替换为 `slog.Debug("请求解密成功，已转发至后端服务。")`。
  - **优先级**: 高。
  - **依赖**: 7.1
  - **产出**: 解密成功的日志仅在 `log_level` 设置为 `debug` 时才会显示。

- [x] **7.3. 迁移请求日志中间件**
  - **描述**: 修改 `internal/middleware/logging.go`，将其中的 `log.Printf` 调用替换为结构化的 `slog.Info` 调用，例如 `slog.Info("incoming request", "method", r.Method, "uri", r.RequestURI, "status", rw.statusCode)`。
  - **优先级**: 高。
  - **依赖**: 7.1
  - **产出**: 请求日志以更清晰、结构化的键值对格式输出。

---

### Phase 8: 打包与部署

**目标**: 为项目添加容器化支持和自动化构建流程，简化部署和发布过程。

- [x] **8.1. 创建 Dockerfile**
  - **描述**: 编写一个多阶段的 `Dockerfile`。第一阶段使用 `golang` 镜像编译 Go 应用，生成一个静态链接的二进制文件。第二阶段使用一个轻量级的 `scratch` 或 `alpine` 镜像，仅复制编译好的二进制文件、`configs` 目录和 `static` 目录，以构建一个最小化的、安全的生产镜像。
  - **优先级**: 高。
  - **依赖**: Phase 1 完成。
  - **产出**: 一个可以工作的 `Dockerfile`，能够构建出可运行的 GoGa 镜像。

- [x] **8.2. 编写 Docker Compose 文件**
  - **描述**: 编写一个 `docker-compose.yml` 文件，仅用于启动 GoGa 网关服务。文件中所有注释必须为中文，且需将项目所有可配置项（如端口、日志级别、加密选项等）都通过环境变量暴露出来，并提供合理的默认值。
  - **优先级**: 中。
  - **依赖**: 8.1。
  - **产出**: 一个符合要求、注释清晰的 `docker-compose.yml` 文件。

---

### Phase 9: 关键 Bug 修复

**目标**: 修正项目中发现的影响核心功能的严重 Bug。

- [x] **9.1. 修复 Viper 配置不生效的 Bug**
  - **描述**: 修复了一个导致 `encryption.enabled` 配置项不生效的严重 Bug。此问题由三个原因共同导致：1) 在 `configs/config.go` 中，内嵌结构体字段缺少 `mapstructure` 标签；2) 在 `cmd/goga/main.go` 中，解密中间件被无条件启用；3) 在 `internal/gateway/proxy.go` 中，前端脚本的注入逻辑也未检查加密开关。此 Bug 已通过补充标签和在后端中间件、前端脚本注入处同时添加条件判断逻辑而彻底修复。
  - **优先级**: 紧急。
  - **依赖**: 无。
  - **产出**: 一个能完全响应所有环境变量和配置文件设置的、行为正确的配置系统。

- [x] **9.2. 【高优】修复解密后未还原原始 `Content-Type` 的 Bug**
  - **描述**: 修复解密中间件在处理完请求后，未将请求的 `Content-Type` 恢复为加密前的原始类型的问题。当前实现会导致所有解密后的请求都以 `application/json` 的类型发送给后端，可能导致后端服务解析失败，这严重违反了“零侵入”设计原则。
  - **优先级**: 高。
  - **依赖**: 3.4 (解密中间件)。
  - **产出**: 一个在解密成功后能正确还原原始 `Content-Type` 的中间件，确保后端服务能无感知地处理请求。

- [x] **9.3. 修复反向代理 Host 头重写问题**
  - **描述**: 修复了 `goga` 网关在作为反向代理时，错误地将传入请求的 `Host` 头重写为后端服务的主机名的问题。这导致了当 `goga` 部署在 Nginx 等上游代理之后时，后端服务无法识别原始域名，从而引发了错误的重定向行为。该问题已通过移除 `internal/gateway/proxy.go` 中 `Director` 函数内 `req.Host = target.Host` 这一行代码来解决，确保了原始的 `Host` 头能够被正确地传递给后端服务，实现了透明代理行为。
  - **优先级**: 紧急。
  - **依赖**: Phase 1 完成。
  - **产出**: `goga` 网关现在能够正确地透传原始 `Host` 头，避免了在使用上游代理时的重定向问题。

---

### Phase 10: 功能增强与改进

**目标**: 实现额外的功能，提升系统灵活性和用户体验。

- [x] **10.1. 【低优】完善 `X-Forwarded-For` 逻辑**
  - **描述**: Go 的标准反向代理 (`httputil.ReverseProxy`) 自动处理 `X-Forwarded-For` 头部，但其默认行为是覆盖或简单添加。更健壮的代理实现通常会检查该头部是否已存在，如果存在，则将新的 IP 追加到链上。当前实现功能足够，但可做得更严谨。
  - **优先级**: 低。
  - **依赖**: 2.3 (反向代理模块)。
  - **产出**: `X-Forwarded-For` 头部被更严谨地处理，确保 IP 地址链的完整性。

- [x] **10.2. 【健壮性】实现脚本注入时的大文件处理**
  - **描述**: 脚本注入逻辑会使用 `io.ReadAll` 将整个 HTML 响应读入内存。如果后端返回一个非常大的 HTML 文件（例如几十 MB），可能会耗尽网关内存。
  - **优先级**: 中。
  - **依赖**: 2.1 (脚本注入逻辑)。
  - **产出**: 在 `ModifyResponse` 中增加一个保护性检查（如 `io.LimitedReader`），如果响应体超出预设限制则放弃注入并记录警告，避免服务因单个大响应而崩溃。

- [x] **10.3. 【性能/体验】实现客户端预取密钥**
  - **描述**: 设计文档建议 JS 脚本在页面加载后立即预取密钥，而不是等到用户提交表单时才去请求。当前脚本在表单提交时才请求密钥，增加了首次提交的延迟。
  - **优先级**: 高 (对用户体验影响较大)。
  - **依赖**: Phase 4/6 完成，客户端脚本需修改。
  - **产出了**: 客户端脚本在 `DOMContentLoaded` 事件后预取并缓存密钥，消除首次提交时的网络延迟，提升响应速度。

- [x] **10.4. 【性能/资源】使用 `sync.Pool` 复用缓冲区**
  - **描述**: 在脚本注入逻辑 (`proxy.go`) 中，每次处理响应都需要分配新的内存来读取和修改响应体。对于处理响应体的 `[]byte` 缓冲区，可以引入 `sync.Pool` 来进行复用，在高并发下可以有效降低 GC 负担。
  - **优先级**: 中。
  - **依赖**: 2.1 (脚本注入逻辑)。
  - **产出**: 通过 `sync.Pool` 复用缓冲区，减少内存分配和 GC 压力。

- [x] **10.5. 【安全】实现 Web 攻击防护**
  - **描述**: 需求文档 (3.2.c) 要求抵御常见的 Web 攻击。当前实现主要关注传输层加密，但缺少对 XSS, CSRF, SSRF 等应用层攻击的专项防护。
  - **优先级**: 中。
  - **依赖**: Phase 1 (核心反向代理基础) 完成。
  - **产出**: 
    - 1. 为所有出站响应添加推荐的安全头部（如 `Content-Security-Policy`, `X-Content-Type-Options`, `X-Frame-Options`）以增强客户端抵御 XSS 的能力。
    - 2. 评估并为网关自身管理或 API 端点（如密钥分发）实现 CSRF 防护机制。
    - 3. 审查并加固反向代理配置，确保其行为能有效防范针对内网的 SSRF（服务器端请求伪造）攻击。

- [X] **10.6. 【中优】实现“按字段加密”** (已标记为“改动过大，暂不处理”类别)
  - **描述**: 客户端脚本应支持可配置地对某些特定表单字段进行加密，而不是对整个表单进行加密。当前 `goga-crypto.js` 将整个表单序列化为 JSON 并加密，不满足部分字段加密的需求。
  - **优先级**: 中。
  - **依赖**: Phase 4 完成，客户端脚本需修改。
  - **产出**: 一个允许用户配置哪些表单字段需要加密的客户端脚本。

- [x] **10.7. 【健壮性】客户端动态配置密钥缓存有效期**
  - **描述**: 修改 `static/goga-crypto.js` 脚本。密钥分发接口 `/goga/api/v1/key` 应返回一个 `ttl` (Time-To-Live) 值，指示密钥的有效时长。客户端脚本应使用此 `ttl` 值（例如，`ttl * 0.8` 作为安全余量）来动态计算和设置本地密钥缓存的有效期，而不是使用硬编码的4分钟。这消除了前后端配置的强耦合，提升了系统的健壮性和灵活性。
  - **优先级**: 高。
  - **依赖**: Phase 4 完成，服务端 `/goga/api/v1/key` 接口需返回 `ttl` 字段。
  - **产出**: 客户端密钥缓存有效期由服务端动态控制，避免因前后端配置不一致导致的解密失败。

- [x] **10.8. 【性能】优化加解密载荷格式，消除二次解析开销**
  - **描述**: 重构客户端与服务端的加解密逻辑。当前实现中，解密后的数据仍需进行一次 JSON 解析来提取原始 `Content-Type` 和 `body`，这在高并发下会带来不必要的 CPU 和内存开销。新方案将采用更紧凑的二进制格式 `[1 字节长度][Content-Type 字符串][原始 Body]` 来取代内部的 JSON 包装。此举将完全移除服务端解密后的二次解析步骤，改为高效的字节切片操作，从而显著降低资源消耗并提升吞吐量。
  - **优先级**: 中。
  - **依赖**: 9.2。
  - **产出**: 一套新的、更高性能的加解密数据传输格式，以及与之配套的客户端和服务端实现。

---

### Phase 11: 密钥管理架构升级 (支持内存与 Redis 双模式)

**背景与设计思路**:

此阶段旨在解决 `Phase 3.2` 中实现的内存密钥缓存在多副本部署下的核心问题。

1.  **问题陈述**: 原有的密钥缓存直接存储于服务实例的内存中。当服务水平扩展（部署多个副本）时，每个副本都有自己独立的密钥缓存。这导致客户端请求在被负载均衡到不同副本时，可能因为目标副本没有相应的解密密钥而失败，破坏了服务的“无状态”原则。

2.  **设计演进**:
    *   **初步方案 (已废弃)**: 最初的思路是直接用一个集中式的 Redis 缓存完全替换掉内存缓存。然而，该方案不够灵活，它会为所有用户（包括仅需单副本运行的简单场景）引入一个强制的、额外的 Redis 依赖，增加了部署复杂性。
    *   **最终方案 (采纳)**: 为了同时兼顾简易性和扩展性，我们采纳了“可插拔后端”的设计模式。我们将定义一个统一的 `KeyCacher` 接口，将缓存的具体实现与业务逻辑解耦。然后，提供两种实现：
        *   `InMemoryKeyCache`: 对现有内存缓存的重构，作为默认选项，保证向后兼容和零外部依赖。
        *   `RedisKeyCache`: 新增的基于 Redis 的实现，用于需要多副本部署的场景。
    通过在配置文件中增加一个开关，用户可以根据自己的部署需求，自由选择使用哪种缓存后端。这套方案是目前最理想的，它为项目未来的可扩展性奠定了坚实的基础，同时又没有牺牲掉简单场景下的易用性。

**目标**: 重构密钥管理模块，实现可插拔的缓存后端。允许通过配置在原有的“内存模式”（适用于单副本部署）和新增的“Redis 模式”（适用于多副本、无状态部署）之间切换，以增强部署灵活性。

- [x] **11.1. 【架构】定义统一密钥缓存接口 (`KeyCacher`)**
  - **描述**:
    1.  在 `internal/gateway` 包中，创建一个名为 `KeyCacher` 的新接口。
    2.  该接口需定义核心的缓存操作方法，至少包括 `Set(token string, key []byte, ttl time.Duration)` 和 `Get(token string) ([]byte, bool)`。
    3.  可能还需包含一个 `Stop()` 方法用于资源清理。
  - **优先级**: 最高 (本阶段的基础)。
  - **依赖**: 无。
  - **产出**: 一个清晰的 `KeyCacher` 接口定义。

- [x] **11.2. 【重构】将现有内存缓存适配到新接口**
  - **描述**:
    1.  将 `internal/gateway/keycache.go` 中现有的 `KeyCache` 重命名为 `InMemoryKeyCache`。
    2.  确保 `InMemoryKeyCache` 结构体完全实现了 `KeyCacher` 接口。
  - **优先级**: 高。
  - **依赖**: 11.1
  - **产出**: 一个实现了 `KeyCacher` 接口的、可继续使用的内存缓存模块。

- [x] **11.3. 【核心】实现 Redis 密钥缓存模块**
  - **描述**:
    1.  在 `internal/gateway` 中创建一个新文件 `redis_keycache.go`。
    2.  创建一个 `RedisKeyCache` 结构体，并为其实现 `KeyCacher` 接口的所有方法。其内部将使用 `go-redis` 客户端与 Redis 服务器交互。
    3.  向 `go.mod` 文件中添加 Redis 客户端库 (例如 `github.com/redis/go-redis/v9`)。
  - **优先级**: 高。
  - **依赖**: 11.1
  - **产出**: 一个实现了 `KeyCacher` 接口的、使用 Redis 作为后端的全新缓存模块。

- [x] **11.4. 【配置】更新配置模块以支持缓存模式切换**
  - **描述**:
    1.  修改 `configs/config.go` 和 `configs/config.example.yaml`。
    2.  在配置中增加一个 `keyCache` 部分，包含 `type` 字段（允许值为 `in-memory` 或 `redis`，默认为 `in-memory`）以及 `redis` 的连接信息。
    3.  确保 Viper 能够正确解析这些新配置。
  - **优先级**: 高。
  - **依赖**: 1.2
  - **产出**: 一套能够灵活配置密钥缓存模式的配置系统。

- [x] **11.5. 【集成】实现缓存工厂函数与依赖注入**
  - **描述**:
    1.  创建一个 `NewKeyCacher` 工厂函数，该函数根据 `keyCache.type` 配置决定是初始化 `InMemoryKeyCache` 还是 `RedisKeyCache`。
    2.  在 `cmd/goga/main.go` 中调用此工厂函数，并将返回的 `KeyCacher` 接口实例注入到所有依赖它的模块中（如解密中间件和密钥分发 API）。
  - **优先级**: 高。
  - **依赖**: 11.2, 11.3, 11.4
  - **产出**: 应用能够根据配置在启动时动态选择并初始化正确的密钥缓存后端。

- [x] **11.6. 【部署】更新 Docker Compose 文件**
  - **描述**:
    1.  修改 `docker-compose.yml`，添加一个可选的 `redis` 服务。
    2.  在 `goga` 服务的环境变量中，提供切换到 Redis 模式所需的所有配置 (`GOGA_KEYCACHE_TYPE`, `GOGA_KEYCACHE_REDIS_ADDR`等)。
    3.  在文档中明确说明，默认情况下无需 Redis 即可运行。
  - **优先级**: 中。
  - **依赖**: 8.2, 11.4
  - **产出**: 一个支持两种部署模式的、更灵活的 `docker-compose.yml` 文件。

---

### Phase 12: 运维性增强 (Operations Enhancement)

**目标**: 全面提升服务的可观测性、可维护性和健壮性，以满足生产环境的运维需求。

- [x] **12.1. 【高优】实现全量日志记录**
  - **描述**: 增强现有日志系统，以满足全量审计需求。
    - 1. **流量日志增强**: 在 `logging` 中间件中增加源 IP (`X-Forwarded-For` 或 `RemoteAddr`)、请求协议等字段的记录。
    - 2. **安全事件日志**: 在实现 Web 攻击防护 (任务 10.6) 或其他安全相关逻辑（如解密失败）时，必须记录详细的、结构化的安全事件日志（包含攻击类型、触发规则、处理结果等）。
    - 3. **日志到文件**: 添加配置项 `log.output_path`，支持将日志输出重定向到指定文件，并考虑日志轮转机制。
  - **优先级**: 高。
  - **依赖**: 7.3 (结构化日志)。
  - **产出**: 一个功能更全面、满足审计要求的日志系统。

- [X] **12.2. 【中优】支持类似 Nginx 的热更新机制（基于配置文件 + reload 信号）** (已标记为“暂不处理”类别)
  - **描述**: 实现类似 Nginx 的配置热加载机制：
    网关的所有运行配置必须只从配置文件读取（不再支持从环境变量读取，也不存在“环境变量优先”规则）。
    当需要更新配置时，由运维人员修改配置文件，然后通过一个专用管理命令触发网关执行热更新，例如：
    goga -s reload
    或向正在运行的网关发送一个内部定义的 reload 信号（如 Unix signal 或本地管理 socket 调用）。
    在接收到 reload 指令后，网关需要：
    重新读取配置文件
    校验配置合法性
    将可热更新的字段（如 log_level, backend_upstreams, ttl 等）安全地应用到运行时
    在日志中记录明确的“配置热更新”操作日志，包括旧值 → 新值
    保证整个过程不重启主服务、不影响现有连接的处理（平滑热更新）
    此机制可使配置文件与实际运行状态始终保持一致，行为与 Nginx 的配置管理方式一致。
  - **优先级**: 中。
  - **依赖**: 1.2 (配置模块)。
  - **产出**: 一个支持通过类似 nginx -s reload 的方式触发配置热加载的网关系统，运行时配置始终来源于配置文件，更新后无需重启即可生效，提升运维一致性与可控性。

- [X] **12.3. 【中优】实现资源监控指标暴露** (已标记为“暂不处理”类别)
  - **描述**: 集成 Prometheus 客户端库，提供一个 `/metrics` 端点以暴露关键的运行时指标，从而支持外部监控和告警系统。
    - 1. **基础指标**: 暴露 Go 运行时指标（如 Goroutine 数量, GC 统计, 内存堆栈信息）。
    - 2. **系统资源**: 暴露进程的 CPU 和内存使用率。
    - 3. **业务指标**: 暴露 HTTP 活动连接数、处理中的请求数以及总出入流量（带宽）。
    - **备注**: 阈值告警功能由外部监控系统（如 Prometheus + Alertmanager）实现，本项目仅负责按标准格式暴露指标数据。
  - **优先级**: 中。
  - **依赖**: Phase 1 (核心反向代理基础)。
  - **产出**: 一个符合 Prometheus 标准的 `/metrics` 端点，为服务监控和告警提供数据支持。

- [x] **12.4. 【高优】实现服务优雅退出 (Graceful Shutdown)**
  - **描述**: 为应用程序实现优雅退出机制，以确保在服务停止或重启（例如，在 Docker 或 Kubernetes 环境中进行滚动更新）时，不会中断正在处理的 HTTP 请求。这是保障服务稳定性和数据一致性的关键生产实践。
    - 1. **监听终止信号**: 在 `cmd/goga/main.go` 中，设置一个通道来监听操作系统的终止信号 (`syscall.SIGINT` 和 `syscall.SIGTERM`)。
    - 2. **启动 Shutdown 流程**: 当接收到终止信号时，程序不应立即退出。应首先记录一条明确的日志，表明“优雅退出流程已启动”。
    - 3. **调用 `http.Server.Shutdown`**: 使用一个带超时的 `context` (例如 5-10 秒) 调用 `http.Server.Shutdown()` 方法。此方法会停止接受新请求，并等待现有请求处理完成。
    - 4. **清理关键资源**: 在 `Shutdown` 方法返回后，执行必要的资源清理工作。最关键的是，需要安全地关闭与 `KeyCacher` 相关的连接（特别是当后端是 Redis 时）。
    - 5. **记录并退出**: 所有清理工作完成后，记录一条“服务已成功关闭”的日志，然后程序正常退出。
  - **优先级**: 高。
  - **依赖**: Phase 1 (核心反向代理基础), Phase 11 (密钥管理架构)。
  - **产出**: 一个能够在接收到终止信号时平滑关闭的 GoGa 服务，确保所有进行中的请求都能被妥善处理，从而在生产环境中实现零停机更新。

---

### Phase 13: 集成测试 (Integration Testing)

**目标**: 增加一套全面的集成测试，以在端到端环境中验证网关的核心功能。

**约束**:
*   所有测试文件必须位于 `/test` 目录中。
*   测试必须遵循标准的 Go 测试约定，并可通过 `go test` 运行。
*   测试应该是自包含的，能够管理 `goga` 网关和 `test-backend` 服务的生命周期。

**任务**:

*   [x] **[任务 1] 创建测试装置和服务器管理**
    *   在 `/test` 包中实现辅助函数，用于根据给定配置启动和停止 `goga` 服务器。
    *   实现用于启动和停止 `test-backend` 服务器的辅助函数。
    *   修改 `test-backend` 服务器的 `/api/login` 处理程序，使其也接受 `application/x-www-form-urlencoded`，以方便测试完整的解密流程。

*   [x] **[任务 2] 实现端到端加密测试 (`TestFullEncryptionFlow`)**
    *   编写一个启动两个服务器的测试。
    *   验证在 `GET` 请求时脚本被注入。
    *   从 API 获取密钥。
    *   模拟客户端对表单有效载荷进行加密。
    *   验证 `test-backend` 收到了正确解密的数据。

*   [x] **[任务 3] 实现加密禁用测试 (`TestEncryptionDisabledFlow`)**
    *   编写一个在禁用加密的情况下启动 `goga` 的测试。
    *   验证脚本未被注入。
    *   验证标准 POST 请求在未经修改的情况下成功代理。

*   [x] **[任务 4] 实现安全性和边缘案例测试**
    *   为无效/过期令牌创建一个测试，断言返回 `401 Unauthorized` 响应 (`TestInvalidToken`)。
    *   创建一个测试，以确保 `/goga-crypto.min.js` 资产被正确提供 (`TestStaticAssetDelivery`)。
    *   为 `/health` 端点创建一个测试 (`TestHealthCheck`)。

*   [x] **[任务 5] 实现应用组装 (main.go) 集成测试**
    *   **描述**: 
        1.  在 `cmd/goga/` 目录下创建 `main_integration_test.go` 文件，并使用 `integration` 构建标签。
        2.  实现一个测试辅助函数，用于在后台启动一个完整的 GoGa 服务器实例。
        3.  编写测试用例，通过发送真实 HTTP 请求来验证中间件链的行为，如健康检查、安全头、Panic 恢复等。
    *   **产出**: 一个能验证 `main.go` 中应用组装和中间件顺序正确性的集成测试。

---

### Phase 14: 响应内容处理优化

**目标**: 提升网关处理来自后端服务的多样化响应内容的能力，特别是处理未正确标识压缩类型的响应。

- [x] **14.1. 自动识别并解压未标识的压缩响应**
  - **描述**: 修复了 GoGa 网关在处理来自第三方服务的 HTML 响应时，无法正确注入脚本的问题。该问题是由于第三方服务返回了 Brotli 压缩的 HTML 内容但未包含标准的 `Content-Encoding` HTTP 头部所致。为了解决此问题，`internal/gateway/proxy.go` 文件中的 `ModifyResponse` 函数已进行修改，增强了响应解压能力。它现在会按以下顺序尝试解压响应体：
    1.  检查标准的 Gzip 压缩 (`Content-Encoding: gzip`)。
    2.  尝试 Zstandard (zstd) 解压。
    3.  尝试 Brotli 解压。
    4.  尝试 LZ4 解压。
    此机制确保即使后端响应未正确标识其压缩类型，网关也能将其解压为原始 HTML，从而解决乱码输出和 `</body>` 标签找不到的问题，并允许脚本成功注入。
  - **优先级**: 高。
  - **依赖**: Phase 2 (HTML 响应处理与脚本注入)
  - **产出**: 网关能够自动识别并解压多种常见的压缩格式（Gzip, Zstandard, Brotli, LZ4），即使后端未提供 `Content-Encoding` 头部。

  ---

  ### Phase 15: 客户端加密安全加固 (Client-Side Encryption Hardening)

**背景**: 当前客户端加密脚本 `static/goga-crypto.js` 的核心安全逻辑依赖于一个在前端代码中定义的 `excludeUrls` 白名单。此设计存在严重的安全风险，因为它错误地假设客户端环境是可信的，而任何在浏览器中运行的代码都可能被最终用户拦截、查看和修改。为应对此威胁，必须采用“纵深防御”策略，其核心原则是“永不信任客户端”，安全策略的最终决策权必须掌握在服务器端。

---

- [x] **15.1. 【最高优】实现服务器端强制校验**
  - **描述**: 作为安全策略的最终防线，在服务端强制执行加密策略。修改解密中间件，使其根据配置文件中新增的 `encryption.must_encrypt_routes` 列表（支持正则表达式）进行检查。如果请求路径匹配该列表，但请求体不是预期的加密格式，则立即以 `422 Unprocessable Entity` 拒绝请求，并记录安全告警。
  - **优先级**: 最高。
  - **依赖**: 3.4 (解密中间件)。
  - **产出**: 一个能强制执行加密策略的、不依赖任何客户端行为的健壮后端。

- [x] **15.2. 【高优】实现子资源完整性 (SRI)**
  - **描述**: 为 `goga-crypto.js` 脚本的加载启用子资源完整性 (SRI) 保护，以防御中间人攻击。在构建流程中为脚本文件生成 SHA-384 哈希，并在 `proxy.go` 的脚本注入逻辑中，将该哈希值添加到 `<script>` 标签的 `integrity` 属性里，同时添加 `crossorigin="anonymous"` 属性。
  - **优先级**: 高。
  - **依赖**: 2.1 (脚本注入逻辑)。
  - **产出**: 一个能抵抗传输层内容篡改的脚本加载机制。如果脚本在网络中被修改，浏览器将直接拒绝执行它。

- [X] **15.3. 【高优】实现客户端运行时自我完整性校验** (已标记为“暂不处理”类别)
  - **描述**: 为 `goga-crypto.js` 增加运行时自我完整性校验，以增加客户端篡改（如修改 `excludeUrls` 白名单）的难度。在构建阶段，计算关键配置的哈希指纹并将其与配置一同嵌入脚本。在脚本运行时，立即重新计算哈希并与嵌入的指纹比对。若不匹配，则立即执行“安全锁定”，通过覆盖 `fetch` 等全局函数来瘫痪所有网络请求。
  - **优先级**: 高。
  - **依赖**: Phase 4 (客户端加密实现)。
  - **产出**: 一个具备“自保”能力的客户端脚本，对关键配置的非法修改将导致脚本功能立即瘫痪，从而阻止攻击。

---

### Phase 16: 客户端加密脚本改进 (Client-Side Script Enhancement)

**目标**: 解决 `goga-crypto.js` 在功能、安全和可维护性方面的不足，提升其健壮性和适用范围。

- [ ] **16.1. [P0] 实现响应体自动解密**
  - **描述**: 扩展 `fetch` 和 `XHR` 拦截器，使其能够处理加密的响应。拦截器需检查响应中是否包含特定标识（如 `X-Goga-Encrypted: true`），如果存在，则使用缓存的密钥对响应体进行解密，然后将解密后的内容返回给应用层。这是实现双向端到端加密的关键。
  - **优先级**: P0 - 核心功能缺失。
  - **依赖**: Phase 4 完成。

- [ ] **16.2. [P0] 扩展支持 `PUT` 和 `PATCH` 请求方法**
  - **描述**: 修改请求拦截器中的方法判断逻辑，将加密范围从仅 `POST` 扩展到 `POST`, `PUT`, `PATCH` 等所有可能携带请求体的方法。
  - **优先级**: P0 - 严重功能缺陷。
  - **依赖**: Phase 4 完成。

- [ ] **16.3. [P0] 支持 `FormData`, `Blob` 等非字符串请求体**
  - **描述**: 重构 `buildEncryptedPayload` 函数，使其能够处理 `FormData` 和 `Blob` 等类型的请求体。对于 `Blob` 类型，可使用 `FileReader` 读取为 `ArrayBuffer`。对于 `FormData`，需要设计一种可序列化的格式（如JSON转换），并在服务端进行相应的适配来还原。
  - **优先级**: P0 - 严重功能缺陷。
  - **依赖**: Phase 4, Phase 3.4。

- [ ] **16.4. [P1] 实现可配置的“失败时阻断” (Fail-Closed) 策略**
  - **描述**: 在 `window.gogaCryptoConfig` 中增加一个配置项（如 `failClosed: true`）。当该选项启用时，如果加密过程失败，脚本应立即中断网络请求并抛出错误，而不是发送明文数据。
  - **优先级**: P1 - 中等安全风险。
  - **依赖**: Phase 4 完成。

- [ ] **16.5. [P2] 将密钥获取URL配置化**
  - **描述**: 将硬编码的 `/goga/api/v1/key` URL 从代码中移除，改为从 `window.gogaCryptoConfig` 中读取（如 `keyApiUrl`）。这可以提高脚本在不同部署环境下的灵活性。
  - **优先级**: P2 - 低优先级可维护性问题。
  - **依赖**: Phase 4 完成。
