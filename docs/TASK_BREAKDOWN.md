# GoGa - 开发任务拆解 (v1.0)

本文档根据系统设计将项目开发分解为一系列可执行的任务。任务按阶段划分，并根据依赖关系进行了优先级排序，确保项目可以迭代、平稳地推进。开发应遵循从底层基础到上层功能的顺序。

---

### Phase 1: 核心反向代理基础

**目标**: 搭建一个可以运行的、功能最小化的 HTTP 反向代理服务器。此阶段不涉及任何加解密逻辑。

- [x] **1.1. 项目初始化与结构搭建**
  - **描述**: 初始化 Go Module (`go mod init`)，并创建设计文档中规划的目录结构 (`cmd/goga`, `configs`, `internal/gateway`, `docs`)。
  - **优先级**: 最高 (项目基石)。
  - **产出**: 一个空的、结构清晰的项目骨架。

- [x] **1.2. 配置模块实现**
  - **描述**: 在 `configs` 包中实现配置加载逻辑。使用 Viper 读取 `config.yaml` 和环境变量 (`server.port`, `backend_url`, `log_level`)。
  - **优先级**: 高。
  - **依赖**: 1.1
  - **产出**: 一个可以加载项目配置的 `config` 模块。

- [x] **1.3. 基础 HTTP 服务启动**
  - **描述**: 在 `cmd/goga/main.go` 中编写主函数。该函数负责加载配置，并启动一个监听在指定端口的 `http.Server`。
  - **优先级**: 高。
  - **依赖**: 1.2
  - **产出**: 一个可以启动并监听端口的空 Web 服务器。

- [x] **1.4. 实现基础反向代理处理器**
  - **描述**: 在 `internal/gateway` 中创建一个 `NewProxy` 函数，该函数使用 `net/http/httputil.ReverseProxy` 创建一个将所有请求转发到 `backend_url` 的 `http.Handler`。
  - **优先级**: 高。
  - **依赖**: 1.3
  - **产出**: 一个能将所有流量正确转发到后端的、可工作的反向代理。

- [x] **1.5. 实现基础中间件 (日志、恢复、健康检查)**
  - **描述**: 创建一个 `middleware` 包，并实现三个基础中间件：
    1.  请求日志 (Logging): 记录方法、路径、状态码、耗时。
    2.  Panic 恢复 (Recovery): 捕获 panic 并返回 500 错误。
    3.  健康检查 (Health Check): 为 `/healthz` 路径返回 `200 OK`。
  - **优先级**: 中。这些是后续调试的重要辅助工具。
  - **依赖**: 1.4
  - **产出**: 一个包裹了代理处理器，并具备基本运维功能的服务。

---

### Phase 2: HTML 响应处理与脚本注入

**目标**: 在核心代理的基础上，实现对 HTML 响应的识别和动态脚本注入功能。

- [x] **2.1. 实现脚本注入逻辑**
  - **描述**: 修改 `internal/gateway` 中的代理处理器，为其 `ModifyResponse` 钩子添加逻辑。该逻辑需要检测响应的 `Content-Type`，如果是 `text/html`，则读取并修改响应体，在 `</body>` 前插入脚本标签。
  - **优先级**: 高。
  - **依赖**: Phase 1 完成。
  - **产出**: 访问 HTML 页面时，响应体中会被自动注入 `<script>` 标签。

- [x] **2.2. 创建并服务化加密脚本文件**
  - **描述**:
    1.  在项目下创建一个 `static` 或类似目录，并放入一个空的 `goga-crypto.js` 文件。
    2.  在网关的路由逻辑中添加一个处理器，用于响应 `GET /goga-crypto.js` 请求，并返回该文件的内容。
  - **优先级**: 高。
  - **依赖**: 2.1
  - **产出**: 浏览器可以通过网关正确下载 `goga-crypto.js` 文件，避免 404 错误。

---

### Phase 3: 服务端加解密核心功能

**目标**: 构建服务端的密钥管理、分发和请求解密能力。

- [x] **3.1. 实现服务端加密工具模块**
  - **描述**: 在 `internal` 中创建一个 `crypto` 包，实现 `AES-256-GCM` 的解密函数。该函数应接受密钥和密文（nonce + ciphertext）作为输入，返回明文。编写对应的单元测试。
  - **优先级**: 最高 (本阶段的基础)。
  - **依赖**: 无外部依赖。
  - **产出**: 一个经过充分测试的、可靠的 `crypto` 工具包。

- [x] **3.2. 实现内存密钥缓存**
  - **描述**: 在 `internal/gateway` 中创建一个 `keycache` 模块。该模块需要实现一个线程安全的、带 TTL (Time-To-Live) 的内存缓存，用于存储 `token` 到 `ONETIME_KEY` 的映射。
  - **优先级**: 高。
  - **依赖**: 无外部依赖。
  - **产出**: 一个用于临时存储一次性密钥的缓存服务。

- [x] **3.3. 实现密钥分发 API 端点**
  - **描述**: 在网关的路由中添加 `GET /goga/api/v1/key` 的处理器。该处理器负责：
    1.  生成一个唯一 `token` 和一个随机的 `ONETIME_KEY`。
    2.  将 `(token, ONETIME_KEY)` 存入密钥缓存。
    3.  以 JSON 格式向客户端返回 `{"key": "...", "token": "..."}`。
  - **优先级**: 中。
  - **依赖**: 3.2
  - **产出**: 客户端可以通过此 API 获取加密所需的一次性密钥和令牌。

- [x] **3.4. 实现请求解密中间件**
  - **描述**: 创建 `DecryptionMiddleware`。该中间件负责：
    1.  检查 `POST` 请求和 `Content-Type`。
    2.  解析 `{"token": ..., "encrypted": ...}` 格式的请求体。
    3.  使用 `token` 从密钥缓存中获取密钥。
    4.  调用 `crypto` 模块解密数据。
    5.  用解密后的明文替换原始请求体，并更新 `Content-Type` 和 `Content-Length`。
  - **优先级**: 中。
  - **依赖**: 3.1, 3.2, 3.3
  - **产出**: 网关能够自动解密符合特定格式的传入请求。

---

### Phase 4: 客户端加密实现

**目标**: 完成客户端 `goga-crypto.js` 的逻辑，使其能够与服务端协同完成整个加密流程。

- [x] **4.1. 编写客户端加密脚本**
  - **描述**: 填充 `goga-crypto.js` 文件的内容，实现设计文档中描述的全部逻辑：
    1.  监听并阻止表单默认提交。
    2.  异步从 `/goga/api/v1/key` 获取密钥和令牌。
    3.  序列化表单数据为 JSON。
    4.  使用 `SubtleCrypto` API (或 `crypto-js`) 执行 `AES-256-GCM` 加密。
    5.  构造加密载荷，并通过 `fetch` 发送到表单的 `action` URL。
  - **优先级**: 高。
  - **依赖**: Phase 3 完成。
  - **产出**: 一个功能完整的客户端加密脚本。

---

### Phase 5: 集成与文档

**目标**: 将所有功能集成在一起，进行端到端测试，并完善文档和配置。

- [x] **5.1. 端到端集成测试**

  - **描述**: 创建一个简单的后端测试服务（例如，一个打印出收到的请求体和头部的 Node.js Express 或 Go HTTP 服务器）。然后手动或通过自动化测试工具，验证整个流程：页面加载 -> 脚  - **本注入 -> 表单提交 -> 加密 -> 解密 -> 后端收到明文。
  - **优先级**: 高。
  - **依赖**: Phase 1-4 全部完成。
  - **产出**: 证明整个系统按预期工作的测试结果。

- [x] **5.2. 添加 TLS 支持**
  - **描述**: 在 `main.go` 中添加入口逻辑，当配置文件中提供了 `tls_cert_path` 和 `tls_key_path` 时，使用 `http.ListenAndServeTLS` 启动服务。
  - **优先级**: 中。
  - **依赖**: Phase 1 完成。
  - **产出**: 网关支持 HTTPS。

- [x] **5.3. 完善文档**
  - **描述**: 更新 `README.md`，提供清晰的编译、配置和运行指南。说明所有配置项的含义和用法。
  - **优先级**: 中。
  - **依赖**: Phase 1-4 全部完成。
  - **产出**: 一份对用户友好的项目说明文档。

---

### Phase 6: 前端性能优化与健壮性提升

**目标**: 优化客户端加密脚本的性能，减少不必要的网络请求，并增强在密钥过期时的用户体验。

- [x] **6.1. 在 goga-crypto.js 中引入客户端密钥缓存**
  - **描述**: 在 `goga-crypto.js` 脚本的闭包（IIFE）中，定义一个用于存储加密密钥、令牌和过期时间戳的内存变量。此缓存将随页面刷新而自动清除。
  - **优先级**: 高。
  - **依赖**: Phase 4 完成。
  - **产出**: 脚本内部具备了存储密钥的缓存结构。

- [x] **6.2. 实现缓存感知的加密流程**
  - **描述**: 修改 `fetch` 拦截器中的加密逻辑。在加密数据前，首先检查密钥缓存。如果缓存中存在有效且未过期的密钥，则直接使用该密钥，跳过网络请求。
  - **优先级**: 高。
  - **依赖**: 6.1
  - **产出**: 在缓存有效期内，重复的 API 调用不再触发对 `/goga/api/v1/key` 的请求。

- [x] **6.3. 实现密钥过期后的无缝自动续期**
  - **描述**: 增强缓存检查逻辑。当检查到缓存中的密钥已过期或不存在时，脚本应能 **自动、透明地** 调用 `originalFetch` 获取新的密钥和令牌，更新缓存， **然后继续完成当前被拦截的加密请求**。此过程对用户无感知，不会因密钥过期而直接导致请求失败或报错。
  - **优先级**: 高 (核心用户体验)。
  - **依赖**: 6.2
  - **产出**: 即使用户长时间停留页面导致密钥过期，下一次 API 调用也能自动续期并成功完成，仅在该次调用时有获取密钥的额外延迟。

- [x] **6.4. 协调客户端与服务端的缓存超时策略**
  - **描述**: 在 `goga-crypto.js` 中为客户端缓存设置一个明确的超时时间（例如4分钟）。此时间必须小于 Go 后端 `keycache` 模块中为密钥设置的服务器端 TTL（例如5分钟），以避免客户端使用一个已被服务端丢弃的密钥。
  - **优先级**: 中。
  - **依赖**: 6.1, 3.2
  - **产出**: 一套协调一致的、能避免竞态问题的缓存超时策略。

---

### Phase 7: 日志系统升级与优化

**目标**: 引入标准的分级日志系统 (`log/slog`)，替换原有的标准库 `log` 调用，使 `log_level` 配置生效，并优化日志输出格式。

- [x] **7.1. 初始化分级日志系统**
  - **描述**: 在 `cmd/goga/main.go` 中，根据配置文件中的 `log_level` (例如 "debug", "info", "warn", "error") 来初始化 `slog` 日志记录器，并将其设置为全局默认实例。
  - **优先级**: 高 (后续任务的基础)。
  - **依赖**: 1.2 (配置模块)。
  - **产出**: 一个配置好的、可供全局使用的分级日志记录器。

- [x] **7.2. 迁移解密中间件日志**
  - **描述**: 修改 `internal/middleware/decryption.go`，将其中的 `log.Println` 调用替换为 `slog.Debug("请求解密成功，已转发至后端服务。")`。
  - **优先级**: 高。
  - **依赖**: 7.1
  - **产出**: 解密成功的日志仅在 `log_level` 设置为 `debug` 时才会显示。

- [x] **7.3. 迁移请求日志中间件**
  - **描述**: 修改 `internal/middleware/logging.go`，将其中的 `log.Printf` 调用替换为结构化的 `slog.Info` 调用，例如 `slog.Info("incoming request", "method", r.Method, "uri", r.RequestURI, "status", rw.statusCode)`。
  - **优先级**: 高。
  - **依赖**: 7.1
  - **产出**: 请求日志以更清晰、结构化的键值对格式输出。

---

### Phase 8: 打包与部署

**目标**: 为项目添加容器化支持和自动化构建流程，简化部署和发布过程。

- [x] **8.1. 创建 Dockerfile**
  - **描述**: 编写一个多阶段的 `Dockerfile`。第一阶段使用 `golang` 镜像编译 Go 应用，生成一个静态链接的二进制文件。第二阶段使用一个轻量级的 `scratch` 或 `alpine` 镜像，仅复制编译好的二进制文件、`configs` 目录和 `static` 目录，以构建一个最小化的、安全的生产镜像。
  - **优先级**: 高。
  - **依赖**: Phase 1 完成。
  - **产出**: 一个可以工作的 `Dockerfile`，能够构建出可运行的 GoGa 镜像。

- [x] **8.2. 编写 Docker Compose 文件**
  - **描述**: 编写一个 `docker-compose.yml` 文件，仅用于启动 GoGa 网关服务。文件中所有注释必须为中文，且需将项目所有可配置项（如端口、日志级别、加密选项等）都通过环境变量暴露出来，并提供合理的默认值。
  - **优先级**: 中。
  - **依赖**: 8.1。
  - **产出**: 一个符合要求、注释清晰的 `docker-compose.yml` 文件。

---

### Phase 9: 关键 Bug 修复

**目标**: 修正项目中发现的影响核心功能的严重 Bug。

- [x] **9.1. 修复 Viper 配置不生效的 Bug**
  - **描述**: 修复了一个导致 `encryption.enabled` 配置项不生效的严重 Bug。此问题由三个原因共同导致：1) 在 `configs/config.go` 中，内嵌结构体字段缺少 `mapstructure` 标签；2) 在 `cmd/goga/main.go` 中，解密中间件被无条件启用；3) 在 `internal/gateway/proxy.go` 中，前端脚本的注入逻辑也未检查加密开关。此 Bug 已通过补充标签和在后端中间件、前端脚本注入处同时添加条件判断逻辑而彻底修复。
  - **优先级**: 紧急。
  - **依赖**: 无。
  - **产出**: 一个能完全响应所有环境变量和配置文件设置的、行为正确的配置系统。

- [ ] **9.2. 【高优】修复解密后未还原原始 `Content-Type` 的 Bug**
  - **描述**: 修复解密中间件在处理完请求后，未将请求的 `Content-Type` 恢复为加密前的原始类型的问题。当前实现会导致所有解密后的请求都以 `application/json` 的类型发送给后端，可能导致后端服务解析失败，这严重违反了“零侵入”设计原则。
  - **优先级**: 高。
  - **依赖**: 3.4 (解密中间件)。
  - **产出**: 一个在解密成功后能正确还原原始 `Content-Type` 的中间件，确保后端服务能无感知地处理请求。

---

### Phase 10: 功能增强与改进

**目标**: 实现额外的功能，提升系统灵活性和用户体验。

- [ ] **10.1. 【中优】实现“按字段加密”**
  - **描述**: 客户端脚本应支持可配置地对某些特定表单字段进行加密，而不是对整个表单进行加密。当前 `goga-crypto.js` 将整个表单序列化为 JSON 并加密，不满足部分字段加密的需求。
  - **优先级**: 中。
  - **依赖**: Phase 4 完成，客户端脚本需修改。
  - **产出**: 一个允许用户配置哪些表单字段需要加密的客户端脚本。

- [ ] **10.2. 【低优】完善 `X-Forwarded-For` 逻辑**
  - **描述**: Go 的标准反向代理 (`httputil.ReverseProxy`) 自动处理 `X-Forwarded-For` 头部，但其默认行为是覆盖或简单添加。更健壮的代理实现通常会检查该头部是否已存在，如果存在，则将新的 IP 追加到链上。当前实现功能足够，但可做得更严谨。
  - **优先级**: 低。
  - **依赖**: 2.3 (反向代理模块)。
  - **产出**: `X-Forwarded-For` 头部被更严谨地处理，确保 IP 地址链的完整性。

- [ ] **10.3. 【性能/体验】实现客户端预取密钥**
  - **描述**: 设计文档建议 JS 脚本在页面加载后立即预取密钥，而不是等到用户提交表单时才去请求。当前脚本在表单提交时才请求密钥，增加了首次提交的延迟。
  - **优先级**: 高 (对用户体验影响较大)。
  - **依赖**: Phase 4/6 完成，客户端脚本需修改。
  - **产出**: 客户端脚本在 `DOMContentLoaded` 事件后预取并缓存密钥，消除首次提交时的网络延迟，提升响应速度。

- [ ] **10.4. 【性能/资源】使用 `sync.Pool` 复用缓冲区**
  - **描述**: 在脚本注入逻辑 (`proxy.go`) 中，每次处理响应都需要分配新的内存来读取和修改响应体。对于处理响应体的 `[]byte` 缓冲区，可以引入 `sync.Pool` 来进行复用，在高并发下可以有效降低 GC 负担。
  - **优先级**: 中。
  - **依赖**: 2.1 (脚本注入逻辑)。
  - **产出**: 通过 `sync.Pool` 复用缓冲区，减少内存分配和 GC 压力。

- [ ] **10.5. 【健壮性】实现脚本注入时的大文件处理**
  - **描述**: 脚本注入逻辑会使用 `io.ReadAll` 将整个 HTML 响应读入内存。如果后端返回一个非常大的 HTML 文件（例如几十 MB），可能会耗尽网关内存。
  - **优先级**: 中。
  - **依赖**: 2.1 (脚本注入逻辑)。
  - **产出**: 在 `ModifyResponse` 中增加一个保护性检查（如 `io.LimitedReader`），如果响应体超出预设限制则放弃注入并记录警告，避免服务因单个大响应而崩溃。

- [ ] **10.6. 【安全】实现 Web 攻击防护**
  - **描述**: 需求文档 (3.2.c) 要求抵御常见的 Web 攻击。当前实现主要关注传输层加密，但缺少对 XSS, CSRF, SSRF 等应用层攻击的专项防护。
  - **优先级**: 中。
  - **依赖**: Phase 1 (核心反向代理基础) 完成。
  - **产出**: 
    - 1. 为所有出站响应添加推荐的安全头部（如 `Content-Security-Policy`, `X-Content-Type-Options`, `X-Frame-Options`）以增强客户端抵御 XSS 的能力。
    - 2. 评估并为网关自身管理或 API 端点（如密钥分发）实现 CSRF 防护机制。
    - 3. 审查并加固反向代理配置，确保其行为能有效防范针对内网的 SSRF（服务器端请求伪造）攻击。

---

### Phase 11: 密钥管理架构升级 (支持内存与 Redis 双模式)

**背景与设计思路**:

此阶段旨在解决 `Phase 3.2` 中实现的内存密钥缓存在多副本部署下的核心问题。

1.  **问题陈述**: 原有的密钥缓存直接存储于服务实例的内存中。当服务水平扩展（部署多个副本）时，每个副本都有自己独立的密钥缓存。这导致客户端请求在被负载均衡到不同副本时，可能因为目标副本没有相应的解密密钥而失败，破坏了服务的“无状态”原则。

2.  **设计演进**:
    *   **初步方案 (已废弃)**: 最初的思路是直接用一个集中式的 Redis 缓存完全替换掉内存缓存。然而，该方案不够灵活，它会为所有用户（包括仅需单副本运行的简单场景）引入一个强制的、额外的 Redis 依赖，增加了部署复杂性。
    *   **最终方案 (采纳)**: 为了同时兼顾简易性和扩展性，我们采纳了“可插拔后端”的设计模式。我们将定义一个统一的 `KeyCacher` 接口，将缓存的具体实现与业务逻辑解耦。然后，提供两种实现：
        *   `InMemoryKeyCache`: 对现有内存缓存的重构，作为默认选项，保证向后兼容和零外部依赖。
        *   `RedisKeyCache`: 新增的基于 Redis 的实现，用于需要多副本部署的场景。
    通过在配置文件中增加一个开关，用户可以根据自己的部署需求，自由选择使用哪种缓存后端。这套方案是目前最理想的，它为项目未来的可扩展性奠定了坚实的基础，同时又没有牺牲掉简单场景下的易用性。

**目标**: 重构密钥管理模块，实现可插拔的缓存后端。允许通过配置在原有的“内存模式”（适用于单副本部署）和新增的“Redis 模式”（适用于多副本、无状态部署）之间切换，以增强部署灵活性。

- [x] **11.1. 【架构】定义统一密钥缓存接口 (`KeyCacher`)**
  - **描述**:
    1.  在 `internal/gateway` 包中，创建一个名为 `KeyCacher` 的新接口。
    2.  该接口需定义核心的缓存操作方法，至少包括 `Set(token string, key []byte, ttl time.Duration)` 和 `Get(token string) ([]byte, bool)`。
    3.  可能还需包含一个 `Stop()` 方法用于资源清理。
  - **优先级**: 最高 (本阶段的基础)。
  - **依赖**: 无。
  - **产出**: 一个清晰的 `KeyCacher` 接口定义。

- [x] **11.2. 【重构】将现有内存缓存适配到新接口**
  - **描述**:
    1.  将 `internal/gateway/keycache.go` 中现有的 `KeyCache` 重命名为 `InMemoryKeyCache`。
    2.  确保 `InMemoryKeyCache` 结构体完全实现了 `KeyCacher` 接口。
  - **优先级**: 高。
  - **依赖**: 11.1
  - **产出**: 一个实现了 `KeyCacher` 接口的、可继续使用的内存缓存模块。

- [x] **11.3. 【核心】实现 Redis 密钥缓存模块**
  - **描述**:
    1.  在 `internal/gateway` 中创建一个新文件 `redis_keycache.go`。
    2.  创建一个 `RedisKeyCache` 结构体，并为其实现 `KeyCacher` 接口的所有方法。其内部将使用 `go-redis` 客户端与 Redis 服务器交互。
    3.  向 `go.mod` 文件中添加 Redis 客户端库 (例如 `github.com/redis/go-redis/v9`)。
  - **优先级**: 高。
  - **依赖**: 11.1
  - **产出**: 一个实现了 `KeyCacher` 接口的、使用 Redis 作为后端的全新缓存模块。

- [x] **11.4. 【配置】更新配置模块以支持缓存模式切换**
  - **描述**:
    1.  修改 `configs/config.go` 和 `configs/config.example.yaml`。
    2.  在配置中增加一个 `keyCache` 部分，包含 `type` 字段（允许值为 `in-memory` 或 `redis`，默认为 `in-memory`）以及 `redis` 的连接信息。
    3.  确保 Viper 能够正确解析这些新配置。
  - **优先级**: 高。
  - **依赖**: 1.2
  - **产出**: 一套能够灵活配置密钥缓存模式的配置系统。

- [x] **11.5. 【集成】实现缓存工厂函数与依赖注入**
  - **描述**:
    1.  创建一个 `NewKeyCacher` 工厂函数，该函数根据 `keyCache.type` 配置决定是初始化 `InMemoryKeyCache` 还是 `RedisKeyCache`。
    2.  在 `cmd/goga/main.go` 中调用此工厂函数，并将返回的 `KeyCacher` 接口实例注入到所有依赖它的模块中（如解密中间件和密钥分发 API）。
  - **优先级**: 高。
  - **依赖**: 11.2, 11.3, 11.4
  - **产出**: 应用能够根据配置在启动时动态选择并初始化正确的密钥缓存后端。

- [x] **11.6. 【部署】更新 Docker Compose 文件**
  - **描述**:
    1.  修改 `docker-compose.yml`，添加一个可选的 `redis` 服务。
    2.  在 `goga` 服务的环境变量中，提供切换到 Redis 模式所需的所有配置 (`GOGA_KEYCACHE_TYPE`, `GOGA_KEYCACHE_REDIS_ADDR`等)。
    3.  在文档中明确说明，默认情况下无需 Redis 即可运行。
  - **优先级**: 中。
  - **依赖**: 8.2, 11.4
  - **产出**: 一个支持两种部署模式的、更灵活的 `docker-compose.yml` 文件。